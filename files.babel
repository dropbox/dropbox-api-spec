namespace files
    "This endpoint contains endpoints and data types for basic file
    operations."

import common

alias Id = String(min_length=1)
alias Path = String(pattern="/.*")
alias PathOrId = String(pattern="(/|id:).*")
alias PathR = String(pattern="(/.*)?")               # A path that can be the root path ("").
alias Rev = String(min_length=9, pattern="[0-9a-f]+") # TODO: Change pattern to "rev:[0-9a-f]{9,}"

alias ReadPath = String(pattern="((/|id:).*)|(rev:[0-9a-f]{9,})")

#
# Metadata definitions and route
#

struct Metadata
    "Metadata for a file or folder."

    union
        file FileMetadata
        folder FolderMetadata
        deleted DeletedMetadata  # Used by list_folder* and search

    name String
        "The last component of the path (including extension).
        This never contains a slash."
    path_lower String
        "The lowercased full path in the user's Dropbox.
        This always starts with a slash."

    example default
        file = default

    example folder_metadata
        folder = default

struct FileMetadata extends Metadata
    id Id?
        "A unique identifier for the file."
    client_modified common.DropboxTimestamp
        "For files, this is the modification time set by the desktop client
        when the file was added to Dropbox. Since this time is not verified
        (the Dropbox server stores whatever the desktop client sends up), this
        should only be used for display purposes (such as sorting) and not,
        for example, to determine if a file has changed or not."
    server_modified common.DropboxTimestamp
        "The last time the file was modified on Dropbox."
    rev Rev
        "A unique identifier for the current revision of a file. This field is
        the same rev as elsewhere in the API and can be used to detect changes
        and avoid conflicts."
    size UInt64
        "The file size in bytes."

    example default
        id = "id:a4ayc_80_OEAAAAAAAAAXw"
        name = "Prime_Numbers.txt"
        path_lower = "/homework/math/prime_numbers.txt"
        client_modified = "2015-05-12T15:50:38Z"
        server_modified = "2015-05-12T15:50:38Z"
        rev = "a1c10ce0dd78"
        size = 7212

struct FolderMetadata extends Metadata
    id Id?
        "A unique identifier for the folder."

    example default
        id = "id:a4ayc_80_OEAAAAAAAAAXz"
        path_lower = "/homework/math"
        name = "math"

struct DeletedMetadata extends Metadata
    "Indicates that there used to be a file or folder at this path, but it no longer exists."
    # TODO: Do we care about whether it's a deleted file or folder?
    # TODO: Add the mtime when it's been deleted?  And the rev???

    example default
        path_lower = "/home/math/pi.txt"
        name = "pi.txt"

union GetMetadataError
    path LookupError

struct GetMetadataArg
    path ReadPath
        "The path of a file or folder on Dropbox"

    example default
        path = "/Homework/math"

    example id
        path = "id:a4ayc_80_OEAAAAAAAAAYa"

route get_metadata (GetMetadataArg, Metadata, GetMetadataError)
    "Returns the metadata for a file or folder."

#
# List folder routes
#

struct ListFolderLongpollArg
    cursor String
        "A cursor as returned by :route:`list_folder` or :route:`list_folder/continue`"
    timeout UInt64(min_value=30, max_value=480) = 30
        "A timeout in seconds. The request will block for at most this length
        of time, plus up to 90 seconds of random jitter added to avoid the
        thundering herd problem. Care should be taken when using this
        parameter, as some network infrastructure does not support long
        timeouts."

struct ListFolderLongpollResult
    changes Boolean
        "Indicates whether new changes are available. If true, call
        :route:`list_folder` to retrieve the changes."
    backoff UInt64?
        "If present, backoff for at least this many seconds before calling
        :route:`list_folder/longpoll` again."

union ListFolderLongpollError
    reset
        "Indicates that the cursor has been invalidated. Call
        :route:`list_folder` to obtain a new cursor."
    other*

route list_folder/longpoll (ListFolderLongpollArg, ListFolderLongpollResult, ListFolderLongpollError)
    "A longpoll endpoint to wait for changes on an account. In conjunction with
    :route:`list_folder`, this call gives you a low-latency way to monitor an
    account for file changes. The connection will block until there are changes
    available or a timeout occurs."

    attrs
        host="notify"

struct ListFolderArg
    path PathR
        "The path to the folder you want to see the contents of."
    recursive Boolean = false
        "If true, list folder operation will be applied recursively to all subfolders.
        And the response will contain contents of all subfolders"

    example default
        path = "/Homework/math"
        recursive = false

struct ListFolderResult
    entries List(Metadata)
        "The files and (direct) subfolders in the folder."
    cursor String
        "Pass the cursor into :route:`list_folder/continue` to see what's
        changed in the folder since your previous query."
    has_more Boolean
        "If true, then there are more entries available. Pass the
        cursor to :route:`list_folder/continue` to retrieve the rest."

    example default
        cursor = "ZtkX9_EHj3x7PMkVuFIhwKYXEpwpLwyxp9vMKomUhllil9q7eWiAu"
        has_more = false

union ListFolderError
    path LookupError
    other*
        "An unspecified error."

route list_folder (ListFolderArg, ListFolderResult, ListFolderError)
    "Returns the contents of a folder."

struct ListFolderContinueArg
    cursor String
        "The cursor returned by your last call to :route:`list_folder` or
        :route:`list_folder/continue`."

    example default
        cursor = "ZtkX9_EHj3x7PMkVuFIhwKYXEpwpLwyxp9vMKomUhllil9q7eWiAu"

union ListFolderContinueError
    path LookupError
    reset
        "Indicates that the cursor has been invalidated. Call
        :route:`list_folder` to obtain a new cursor."
    other*

route list_folder/continue (ListFolderContinueArg, ListFolderResult, ListFolderContinueError)
    "Once a cursor has been retrieved from :route:`list_folder`, use this to
    paginate through all files and retrieve updates to the folder.

    NOTE: We're definitely going to streamline this interface."

struct ListFolderGetLatestCursorResult
    cursor String
        "Pass the cursor into :route:`list_folder/continue` to see what's
        changed in the folder since your previous query."

    example default
        cursor = "ZtkX9_EHj3x7PMkVuFIhwKYXEpwpLwyxp9vMKomUhllil9q7eWiAu"

route list_folder/get_latest_cursor (ListFolderArg, ListFolderGetLatestCursorResult, ListFolderError)
    "A way to quickly get a cursor for the folder's state. Unlike :route:`list_folder`,
    :route:`list_folder/get_latest_cursor` doesn't return any entries. This endpoint is for app
    which only needs to know about new files and modifications and doesn't need to know about
    files that already exist in Dropbox."

#
# Download
#

union DownloadError
    path LookupError
    other*
        "An unspecified error."

struct DownloadArg
    path Path
        "The path of the file to download."
    rev Rev?
        "Optional revision, taken from the corresponding :type:`Metadata` field."

    example default
        path = "/Homework/math/Prime_Numbers.txt"

    example with_rev
        path = "/Homework/math/Prime_Numbers.txt"
        rev = "a1c10ce0dd78"

route download (DownloadArg, FileMetadata, DownloadError)
    "Download a file from a user's Dropbox."

    attrs
        host="content"
        style="download"

#
# Upload Routes
#

# Errors

struct UploadWriteFailed
    reason WriteError
        "The reason why the file couldn't be saved."
    upload_session_id String
        "The upload session ID; this may be used to retry the commit."

union UploadError
    path UploadWriteFailed
        "Unable to save the uploaded contents to a file."
    other*
        "An unspecified error."

struct UploadSessionOffsetError
    correct_offset UInt64
        "The offset up to which data has been collected."

union UploadSessionLookupError
    not_found
        "The upload session id was not found."
    incorrect_offset UploadSessionOffsetError
        "The specified offset was incorrect. See the value for the
        correct offset. (This error may occur when a previous request
        was received and processed successfully but the client did not
        receive the response, e.g. due to a network error.)"
    closed
        "You are attempting to append data to an upload session that
        has alread been closed (i.e. committed)."
    other*
        "An unspecified error."

union UploadSessionFinishError
    lookup_failed UploadSessionLookupError
        "The session arguments are incorrect; the value explains the reason."
    path WriteError
        "Unable to save the uploaded contents to a file."
    other*
        "An unspecified error."

# Req/Resp

struct UploadSessionStartResult
    session_id String
        "A unique identifier for the upload session. Pass this to
        :route:`upload_session/append` and
        :route:`upload_session/finish`."

    example default
        session_id = "1234faaf0678bcde"

route upload_session/start (Void, UploadSessionStartResult, Void)
    "Upload sessions allow you to upload a single file using multiple requests.
    This call starts a new upload session with the given data.  You can
    then use :route:`upload_session/append` to add more data and
    :route:`upload_session/finish` to save all the data to a file in Dropbox."

    attrs
        host="content"
        style="upload"

struct UploadSessionCursor
    session_id String
        "The upload session ID (returned by :route:`upload_session/start`)."
    offset UInt64
        "The amount of data that has been uploaded so far. We use this to make
        sure upload data isn't lost or duplicated in the event of a network
        error."

    example default
        session_id = "1234faaf0678bcde"
        offset = 0

route upload_session/append (UploadSessionCursor, Void, UploadSessionLookupError)
    "Append more data to an upload session."

    attrs
        host="content"
        style="upload"

union WriteMode
    "Your intent when writing a file to some path. This is used to determine
    what constitutes a conflict and what the autorename strategy is.

    In some situations, the conflict behavior is identical:
    (a) If the target path doesn't contain anything, the file is always written;
    no conflict.
    (b) If the target path contains a folder, it's always a conflict.
    (c) If the target path contains a file with identical contents, nothing gets
    written; no conflict.

    The conflict checking differs in the case where there's a file at the target
    path with contents different from the contents you're trying to write."

    add
        "Never overwrite the existing file. The autorename strategy is to append
        a number to the file name. For example, \"document.txt\" might become
        \"document (2).txt\"."
    overwrite
        "Always overwrite the existing file. The autorename
        strategy is the same as it is for :field:`add`."
    update Rev
        "Overwrite if the given \"rev\" matches the existing file's \"rev\".
        The autorename strategy is to append the string \"conflicted copy\"
        to the file name. For example, \"document.txt\" might become
        \"document (conflicted copy).txt\" or \"document (Panda's conflicted copy).txt\"."

    example default
        add = null

    example overwriting
        overwrite = null

    example with_revision
        update = "a1c10ce0dd78"

struct CommitInfo
    path Path
        "Path in the user's Dropbox to save the file."
    mode WriteMode = add
        "Selects what to do if the file already exists."
    autorename Boolean = false
        "If there's a conflict, as determined by :field:`mode`, have the Dropbox
        server try to autorename the file to avoid conflict."
    client_modified common.DropboxTimestamp?
        "The value to store as the :field:`client_modified` timestamp. Dropbox
        automatically records the time at which the file was written to the
        Dropbox servers. It can also record an additional timestamp, provided
        by Dropbox desktop clients, mobile clients, and API apps of when the
        file was actually created or modified."
    mute Boolean = false
        "Normally, users are made aware of any file modifications in their
        Dropbox account via notifications in the client software. If
        :val:`true`, this tells the clients that this modification shouldn't
        result in a user notification."

    example default
        path = "/Homework/math/Matrices.txt"
        autorename = true

struct UploadSessionFinishArg
    cursor UploadSessionCursor
        "Contains the upload session ID and the offset."
    commit CommitInfo
        "Contains the path and other optional modifiers for the commit."

    example default
        cursor = default
        commit = default

route upload_session/finish (UploadSessionFinishArg, FileMetadata, UploadSessionFinishError)
    "Finish an upload session and save the uploaded data to the given file
    path."

    attrs
        host="content"
        style="upload"

route upload (CommitInfo, FileMetadata, UploadError)
    "Create a new file with the contents provided in the request."

    attrs
        host="content"
        style="upload"

#
# Search
#

union SearchMode
    filename
        "Search file and folder names."
    filename_and_content
        "Search file and folder names as well as file contents."
    deleted_filename
        "Search for deleted file and folder names."

    example default
        filename_and_content = null

    example name_only
        filename = null

    example deleted_names
        deleted_filename = null

struct SearchArg
    path PathR
        "The path in the user's Dropbox to search. Should probably be
        a folder."
    query String
        "The string to search for. The search string is split on spaces into
        multiple tokens. For file name searching, the last token is used for
        prefix matching (i.e. \"bat c\" matches \"bat cave\" but not \"batman
        car\")."
    start UInt64 = 0
        "The starting index within the search results (used for paging)."
    max_results UInt64(min_value=1, max_value=1000) = 100
        "The maximum number of search results to return."
    mode SearchMode = filename
        "The search mode (filename, filename_and_content, or deleted_filename)."

    example default
        path = ""
        query = "prime numbers"

union SearchMatchType
    "Indicates what type of match was found for a given item."

    filename
        "This item was matched on its file or folder name."
    content
        "This item was matched based on its file contents."
    both
        "This item was matched based on both its contents and its file name."

    example default
        content = null

struct SearchMatch
    match_type SearchMatchType
        "The type of the match."
    metadata Metadata
        "The metadata for the matched file or folder."

    example default
        match_type = default
        metadata = default

struct SearchResult
    matches List(SearchMatch)
        "A list (possibly empty) of matches for the query."
    more Boolean
        "Used for paging. If true, indicates there is another page of results
        available that can be fetched by calling :route:`search` again."
    start UInt64
        "Used for paging. Value to set the start argument to when calling
        :route:`search` to fetch the next page of results."

    example default
        more = false
        start = 1

union SearchError
    path LookupError
    other*
        "An unspecified error."

route search (SearchArg, SearchResult, SearchError)
    "Searches for files and folders."

#
# Errors shared by various operations
#

alias MalformedPathError = String?  # TODO: Maybe a user_message-like thing?

union LookupError
    malformed_path MalformedPathError
    not_found
        "There is nothing at the given path."
    not_file
        "We were expecting a file, but the given path refers to something that isn't a file."
    not_folder
        "We were expecting a folder, but the given path refers to something that isn't a folder."
    restricted_content
        "The file cannot be transferred because the content is restricted.  For example,
        sometimes there are legal restrictions due to copyright claims."
    other*

union WriteError
    malformed_path MalformedPathError
    conflict WriteConflictError
        "Couldn't write to the target path because there was something in the way."
    no_write_permission
        "The user doesn't have permissions to write to the target location."
    insufficient_space
        "The user doesn't have enough available space (bytes) to write more data."
    disallowed_name
        "Dropbox will not save the file or folder because it of its name."
    other*

union WriteConflictError
    file
        "There's a file in the way."
    folder
        "There's a folder in the way."
    file_ancestor
        "There's a file at an ancestor path, so we couldn't create the required parent folders."
    other*

#
# Create folder
#

struct CreateFolderArg
    path Path
        "Path in the user's Dropbox to create."

    example default
        path = "/Homework/geometry"

union CreateFolderError
    path WriteError

route create_folder (CreateFolderArg, FolderMetadata, CreateFolderError)
    "Create a folder at a given path."

#
# Delete
#

struct DeleteArg
    path Path
        "Path in the user's Dropbox to delete."

    example delete
        path = "/Homework/math/Prime_Numbers.txt"

union DeleteError
    path_lookup LookupError
    path_write WriteError
    other*

route delete (DeleteArg, Metadata, DeleteError)
    "Delete the file or folder at a given path.

    If the path is a folder, all its contents will be deleted too."

#
# Args and error shared by copy and move
#

struct RelocationArg
    from_path Path
        "Path in the user's Dropbox to be copied or moved."
    to_path Path
        "Path in the user's Dropbox that is the destination."

    example default
        from_path = "/Homework/math"
        to_path = "/Homework/algebra"


union RelocationError
    from_lookup LookupError
    from_write WriteError
    to WriteError

    cant_copy_shared_folder
        "Shared folders can't be copied."
    cant_nest_shared_folder
        "Your move operation would result in nested shared folders.  This is not allowed."
    too_many_files
        "The operation would involve more than 10,000 files and folders."
    other*
        "An unspecified error."

#
# Copy
#

route copy (RelocationArg, Metadata, RelocationError)
    "Copy a file or folder to a different location in the user's Dropbox.

    If the source path is a folder all its contents will be copied."

#
# Move
#

route move (RelocationArg, Metadata, RelocationError)
    "Move a file or folder to a different location in the user's Dropbox.

    If the source path is a folder all its contents will be moved."

#
# Thumbnail
#

union ThumbnailSize
    w32h32
        "32 by 32 px."
    w64h64
        "64 by 64 px."
    w128h128
        "128 by 128 px."
    w640h480
        "640 by 480 px."
    w1024h768
        "1024 by 768"

union ThumbnailFormat
    jpeg
    png

struct ThumbnailArg
    path Path
        "The path to the image file you want to thumbnail."
    format ThumbnailFormat = jpeg
        "The format for the thumbnail image, jpeg (default) or png. For
         images that are photos, jpeg should be preferred, while png is
         better for screenshots and digital arts."
    size ThumbnailSize = w64h64
        "The size for the thumbnail image."

    example default
        path = "/image.jpg"
        format = jpeg

union ThumbnailError
    path LookupError
        "An error occurs when downloading metadata for the image."
    unsupported_extension
        "The file extension doesn't allow conversion to a thumbnail."
    unsupported_image
        "The image cannot be converted to a thumbnail."
    conversion_error
        "An error occurs during thumbnail conversion."

route get_thumbnail(ThumbnailArg, FileMetadata, ThumbnailError)
    "Get a thumbnail for an image.

    This method currently supports files with the following file extensions:
    jpg, jpeg, png, tiff, tif, gif and bmp. Photos that are larger than 20MB
    in size won't be converted to a thumbnail."

    attrs
        host="content"
        style="download"

#
# Preview
#

struct PreviewArg
    path Path
        "The path of the file to preview."
    rev Rev?
        "Optional revision, taken from the corresponding :type:`Metadata` field."

    example default
        path = "/word.docx"

    example with_rev
        path = "/word.docx"
        rev = "a1c10ce0dd78"

union PreviewError
    path LookupError
        "An error occurs when downloading metadata for the file."
    in_progress
        "This preview generation is still in progress and the file is not ready
         for preview yet."
    unsupported_extension
        "The file extension is not supported preview generation."
    unsupported_content
        "The file content is not supported for preview generation."

route get_preview(PreviewArg, FileMetadata, PreviewError)
    "Get a preview for a file. Currently previews are only generated for the files with
     the following extensions: .doc, .docx, .docm, .ppt, .pps, .ppsx, .ppsm, .pptx, .pptm,
     .xls, .xlsx, .xlsm, .rtf"

    attrs
        host="content"
        style="download"

#
# List revisions
#

struct ListRevisionsArg
    path Path
        "The path to the file you want to see the revisions of."

    limit UInt64(min_value=1, max_value=100) = 10
        "The maximum number of revision entries returned."

    # TODO: Add last_rev when we get pagination support from FJ Service.

    example default
        path = "/root/word.docx"
        limit = 10

union ListRevisionsError
    path LookupError
    other*

struct ListRevisionsResult
    is_deleted Boolean
        "If the file is deleted."
    entries List(FileMetadata)
        "The revisions for the file. Only non-delete revisions will show up here."

route list_revisions(ListRevisionsArg, ListRevisionsResult, ListRevisionsError)
    "Return revisions of a file"

#
# Restore
#

struct RestoreArg
    path Path
        "The path to the file you want to restore."
    rev Rev
        "The revision to restore for the file."

    example default
        path = "/root/word.docx"
        rev = "a1c10ce0dd78"

union RestoreError
    path_lookup LookupError
        "An error occurs when downloading metadata for the file."
    path_write WriteError
        "An error occurs when trying to restore the file to that path."
    invalid_revision
        "The revision is invalid. It may point to a different file."

    other*

route restore(RestoreArg, FileMetadata, RestoreError)
    "Restore a file to a specific revision"
